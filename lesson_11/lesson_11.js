// let shopList = []

// Полная версия
// if (shopList) { // Пустой массив - true
//   console.log("Есть что купить");
// }
// else {
//   console.log("Список пуст");
// }

///// Итерируемость - способность объекта быть перебираемым
// Самый простой тип итерируемого объекта - строка
// Строка - упорядоченная неизменяемая итерируемая коллекция символов

// let string = "Программирование это не спринт, а марафон";

// for (let i = 0; i < string.length; i++) {


// Версия Ивана (for of)
// for - ключевое слово цикла
// () - логика цикла, то что будет происходить на каждой итерации
// {} - тело цикла

// for (char of string) {
//     console.log(char);
// }
// Цикл for of - это цикл перебора итерируемого объекта
// мы помещаем в переменную char значение из итерируемого объекта
// и выводим его в консоль

// for (let index in string) {
//   console.log(index);
//   console.log(string[index]);
//   console.log(`Индекс: ${index}, значение: ${string[index]}`);
// }

// Классический цикл for состоит из трех частей:
// 1. Инициализация переменной
// 2. Условие
// 3. Изменение переменной (изменение на каждой итерации цикла)

// for (let i = 0; i < 42; i = i + 1) {
// //   console.log(i);
//   console.log(string[i])
// }

// пока length = 4 НО индексы от 0 до 3
// i++ - это то же самое, что и i = i + 1, увеличение на 1
// for (let i = 0; i < string.length; i++) {
//     //   console.log(i);
//       console.log(string[i])
//     }

// Вынесем переменную и шаг
// Переменная до цикла
// Шаг внутри цикла
// Условие пока оставим

// let j = 0;

// for (; j < string.length;) {
//   console.log(string[j]);
//   j++;
// }

// Практика!
// 0. Переменные. finalSum, userInput
// 1. Получить от пользователя числа (они будут строками)
// 2. Объявить цикл и пройтись по ним, превращая в числа
// 3. Сложить их и вывести сумму


// let finalSum = 0;
// let userInput = prompt("Введите числа без пробела");

// for (let num of userInput) {
//     finalSum += Number(num);
// }

// Array - массив. Упорядоченная коллекция 
// Массив может содержать в себе любые типы данных

// Синтаксис: []

// let nameString = "Иван Екатерина Григорий Владимир Артем";
// let nameArray2 = nameString.split(" ")
// let nameArray = ['Иван', 'Екатерина', 'Григорий', 'Владимир', 'Артем'];

// for (let name of nameArray) {
//     console.log(name)
// };

// nameArray.forEach(name => console.log(name))

// Напишем программу, которая на вход возьмет список слов
// И оставим только те, в которых нет буквы Р

let badLetter = 'р';
let userWords = prompt('Введите список слов через пробел').split(' ')
let goodWords = ''
let badWords = ''

for (let word of userWords) {
    let lowerWord = word.toLocaleLowerCase()
    if (!lowerWord.includes(badLetter)) {
        goodWords = goodWords + word + " "
    }
    else {
        badWords = badWords + word + " "
    };
};

console.log(goodWords.trim().split(' '))
console.log(badWords.trim().split(' '))


// Методы массивов ///////////////////////////
//push
//shift
// pop
// unshift
// forEach(callback) — Выполняет указанную функцию для каждого элемента массива. Ничего не возвращает.
// map(callback) — Создает новый массив, состоящий из результатов вызова функции для каждого элемента.
// filter(callback) — Создает новый массив с элементами, прошедшими проверку, заданную в функции.
// reduce(callback, initialValue) — Применяет функцию к аккумулятору и каждому элементу массива (слева направо), сводя массив к единственному значению.
// find(callback) — Возвращает первый элемент массива, который удовлетворяет условию, заданному в функции.
// findIndex(callback) — Возвращает индекс первого элемента, который удовлетворяет условию, заданному в функции.
// some(callback) — Проверяет, удовлетворяет ли хотя бы один элемент массива условию, заданному в функции.
// every(callback) — Проверяет, удовлетворяют ли все элементы массива условию, заданному в функции.
// sort(compareFunction) — Сортирует элементы массива на месте и возвращает отсортированный массив.
// reverse() — Изменяет порядок элементов в массиве на обратный.
// concat(value) — Объединяет два или более массива, возвращая новый массив.
// slice(start, end) — Возвращает новый массив, содержащий копию части исходного массива от start до end (не включая end).
// splice(start, deleteCount, item1, item2, ...) — Изменяет содержимое массива, удаляя существующие элементы и/или добавляя новые.
// indexOf(searchElement) — Возвращает первый индекс, по которому данный элемент может быть найден в массиве, или -1, если такого элемента нет.
// includes(value) — Проверяет, содержит ли массив определённый элемент, возвращает true или false.
// join(separator) — Объединяет все элементы массива в строку, используя указанный разделитель.
// flat(depth) — Возвращает новый массив с объединенными подмассивами на указанную глубину.
// flatMap(callback) — Применяет функцию к каждому элементу и затем объединяет результаты в новый массив.
// reduceRight(callback, initialValue) — Применяет функцию к аккумулятору и каждому элементу массива (справа налево), сводя массив к единственному значению.
// fill(value, start, end) — Заполняет все элементы массива от начального до конечного индекса указанным значением.
// from(arrayLike, mapFn, thisArg) — Создает новый массив из подобного массива или итерируемого объекта.
// copyWithin(target, start, end) — Копирует часть массива в другую позицию внутри того же массива, не изменяя его размер.