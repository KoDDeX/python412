"""
Lesson 7

Множества (set):
    
1. Основы множеств
    - Концепция множеств в Python
    - Неупорядоченность и уникальность элементов
    - Изменяемые (set) и неизменяемые (frozenset) множества
    
2. Создание и модификация
    - Создание множеств
    - Добавление элементов (add)
    - Удаление элементов (remove, discard, pop)
    - Очистка множества (clear)

3. Операции над множествами
    - Объединение (union, |)
    - Пересечение (intersection, &)
    - Разность (difference, -)
    - Симметрическая разность (symmetric_difference, ^)
    
4. Методы множеств
    - issubset() - является ли подмножеством
    - issuperset() - является ли надмножеством
    - isdisjoint() - не пересекаются ли множества
    
5. Практическое применение
    - Удаление дубликатов из последовательностей
    - Проверка уникальности элементов
    - Поиск общих элементов
    - Фильтрация данных

6. Выражения множеств (Set Comprehension)
    - Синтаксис {expression for item in sequence}
    - Фильтрация в выражениях множеств
    - Сравнение с генераторами списков
    - Оптимизация через выражения множеств

7. Практические задания:
    - Работа с множествами городов/стран
    - Анализ общих интересов пользователей
    - Фильтрация списков через множества
    - Оптимизация поиска через множества
    - Создание множеств через выражения
"""

"""
Список - упорядоченная коллекция элементов, где у каждого элемента есть индекс. Под индексом лежит ссылка на объект.
Сет - коллекция уникальных неизменяемых элементов.
"Владимир" hash() -> 21341279713 -> 21341279713  
"""

# Множества - неупорядоченная коллекция уникальных элементов (только неизменяемые типы данных)

# Создание множеств
empty_set = {} # Это будет словарь!!!!
empty_set = set() # Это будет множество

# Не пустой сет
my_set = {1, 2, 3, 4, None, True, False, 'Hello', 3.14, (1, 2, 3)}

# Пытаемся поместить список в сет, получаем это:
# TypeError: unhashable type: 'list'

# Проверка уникальности
product_set = {"хлеб", "хлеб", "молоко", "Молоко", "кефир"}
# print(product_set)

# hash() - функция, которая возвращает хеш объекта. Хеш - это число, которое используется для быстрого сравнения объектов.

a = "Молоко"
b = "Молоко"
с = "молоко"
d = "молоко"

# print(id(a))
# print(id(b))
# print(id(с))
# print(id(d))

# print(hash(a))
# print(hash(b))
# print(hash(с))
# print(hash(d))

# Практика с сетами
"""
Сделайте пользовательский ввод. 
Разбейте его на слова split()
Обойдите его циклом (а лучше list comprehension и приведите в нижний регистр.
Сделайте из него множество set(user_words_list)
Выведите на экран количество уникальных слов. len(user_words_set)
"""

# user_words = input('Введите слова через пробел')
# user_words_list = user_words.split()
# user_lower_words_list = [word.lower() for word in user_words_list]
# user_words_set = set(user_lower_words_list)
# print(len(user_words_set))
# print(user_words_set)


# Set comprehension - выражение множества
# Как пишется? {что for что in коллекция if фильтр}
# Приемлимо)

# result = {word for word in input('Введите слова через пробел').lower().split()}
# print(len(result))

# Плохо. Слишком много действй в одну строку. Хотя для одноразового события, может сгодиться.
# print(len({word for word in input().lower().split()}))


# Методы множеств

# add - добавляет элемент в множество
# remove(element) - удаляет элемент из множества. Если элемента нет, то выбрасывает ошибку.
# discard(element) - удаляет элемент из множества. Если элемента нет, то ничего не делает.
# pop() - удаляет случайный элемент из множества и возвращает его. Если множество пустое, то выбрасывает ошибку.
# clear() - удаляет все элементы из множества.
# set() - создает множество из последовательности.
# frozenset() - создает неизменяемое множество.
# in - проверяет, есть ли элемент в множестве.
# union - объединение множеств. Оператор |.
# intersection - пересечение множеств. Оператор &.
# difference - разность множеств. Оператор -.
# symmetric_difference - симметрическая разность множеств. Оператор ^.
# issubset - является ли множество подмножеством другого множества.
# issuperset - является ли множество
# isdisjoint - не пересекаются ли множества.

# some_set = {"Лондон", "Москва", "Париж", "Берлин", "Токио"}
# add - добавляет элемент в множество
# some_set.add("Астана")
# print(some_set)
# remove(element) - удаляет элемент из множества. Если элемента нет, то выбрасывает ошибку.
# some_set.remove("Берлин")
# print(some_set)
# discard(element) - удаляет элемент из множества. Если элемента нет, то ничего не делает.
# some_set.discard("Берлин")
# print(some_set)
# pop() - удаляет случайный элемент из множества и возвращает его. Если множество пустое, то выбрасывает ошибку.
# random_city = some_set.pop()
# print(random_city)

# While - пока выполняется условие.
# While True: - бесконечный цикл. Выход из цикла - break.
# count = 0
# while True:
#     user_input = input('Купи айфон: ')
#     if user_input == 'айфон':
#         print('Молодец!')
#         break
    
#     elif user_input == '':
#         print('Ну чё молчишь, купи айфон!')

#     else:
#         print(f'Все говорят {user_input}, а ты купи айфон!')

#     count += 1
#     if count > 9:
#         print('Злюка!')
#         break


# some_set = {"Буря в стакане", "Шматрица", "Шырменатор", "Люди Г", "Операция Х"}

# while some_set:
#     print(some_set.pop())

# Практика
"""
Подкидываем монетку через while и сеты
1. Сделайте переменную счетчик (опционально, это может быть пользовательским вводом - сколько хотите раз подкинуть монетку)
2. Сделайте цикл while пока счетчик меньше 10
3. Внутри цикла сделайте сет с 2 строками, орел, решка
4. Сделайте принт сет.pop и счетчик + 1

Давайте разберем полную картину:

В Python строковые литералы (строки в кавычках) интернируются - это значит, что Python повторно использует уже созданные строки вместо создания новых копий. Когда вы пишете {'орел', 'решка'} много раз в цикле, Python не создает новые строки каждый раз, а использует ссылки на уже существующие.

Представьте это как колоду карт:

У вас есть две карты: Туз ♠️ (орел) и Король ♠️ (решка)
Каждый раунд вы:
Берете КОПИИ этих же самых карт (но это те же самые карты, просто новая колода)
Раскладываете их по тем же правилам (хеширование)
Туз всегда ложится слева, потому что его "вес" (хеш) меньше
Король всегда справа
Берете левую карту (pop берет первый элемент по хешу)
И получаете каждый раз Туза!

"""

# count = user_input = int(input('Сколько раз подкинуть монетку? '))

# while count > 0:
#     a = 'Орел'
#     b = 'Решка'
#     print(hash(a))
#     print(hash(b))
#     coin_set = {a, b}
#     print(coin_set.pop())
#     count -= 1

# from random import choice

# count = user_input = int(input('Сколько раз подкинуть монетку? '))

# while count > 0:
#     a = 'Орел'
#     b = 'Решка'
#     coin_lst = [a, b]
#     print(choice(coin_lst))
#     count -= 1

"""
Перепишите этот код.
Сделайте 2 счетчика для орлов и для решек.
В конце, выведите на экран, сколько орлов и решек выпало.
"""

from random import choice



count = user_input = int(input('Сколько раз подкинуть монетку? '))
count_heads = 0
count_tails = 0

while count > 0:
    a = 'Орел'
    b = 'Решка'
    coin_lst = [a, b]
    result = choice(coin_lst)
    
    if result == 'Орел':
        count_heads += 1
        print(f'Выпал орел')
    else:
        count_tails += 1
        print(f'Выпала решка')
    
    count -= 1

print(f'Выпало орлов: {count_heads}')
print(f'Выпало решек: {count_tails}') # 10

